proc	f1		
+	1	a	@temp1
return	@temp1		
endp	f1		
proc	f2		
=	i	0	
-	0	12	@temp2
=	j	@temp2	
=	k	320	
=	a	45	
=	b	50	
=	c	47	
=	d	95	
return	97		
endp	f2		
proc	recursion		
==	i	1	
jz	L1:		
return	1		
jmp	L2:		
label	L1:		
-	i	1	@temp3
pushpara	@temp3		
call	recursion	@temp4	
+	i	@temp4	@temp4
return	@temp4		
label	L2:		
endp	recursion		
proc	f3		
=	s[0]	0	
+	s[0]	5	@temp5
=	s[1]	@temp5	
=	d[0]	49	
=	d[1]	50	
=	i	1	
=	j	2	
=	k	-3	
=	a	d[1]	
+	i	j	@temp6
-	k	j	@temp7
*	@temp6	@temp7	@temp6
-	s[0]	s[1]	@temp8
-	@temp6	@temp8	@temp6
+	d[0]	j	@temp9
+	@temp9	a	@temp9
/	@temp6	@temp9	@temp6
-	0	@temp6	@temp10
*	@temp10	i	@temp10
-	0	@temp10	@temp11
/	a	-3	@temp12
-	@temp11	@temp12	@temp11
=	m	@temp11	
printf	m		
pushpara	i		
pushpara	a		
call	f1	@temp13	
=	k	@temp13	
endp	f3		
proc	main		
scanf	i		
scanf	j		
=	a	97	
==	i	0	
jz	L3:		
printStr	"i=0"		
jmp	L4:		
label	L3:		
printStr	"i!=0"		
label	L4:		
!=	j	0	
jz	L5:		
printStr	"j!=0"		
label	L5:		
=	i	2	
=	j	0	
label	L6:		
-	i	1	@temp14
=	i	@temp14	
=	k[j]	i	
+	j	1	@temp15
=	j	@temp15	
>	i	0	
jnz	L6:		
scanf	j		
=	i	0	
label	L8:		
<	i	j	
jz	L7:		
+	i	j	@temp16
printf	@temp16		
+	i	1	i
jmp	L8:		
label	L7:		
+	j	i	@temp17
pushpara	@temp17		
pushpara	97		
call	f1	@temp18	
=	i	@temp18	
printf	i		
pushpara	i		
pushpara	99		
call	f2	@temp19	
=	a	@temp19	
printf	a		
callvoid	f3		
pushpara	1		
call	recursion	@temp20	
=	i	@temp20	
printf	i		
pushpara	3		
call	recursion	@temp21	
=	i	@temp21	
printf	i		
return			
endp	main		
